import 'dart:io';

import 'package:change_case/change_case.dart';
import 'package:path/path.dart' as path;
import 'package:supabase_codegen/src/generator/generator.dart';
import 'package:supabase_codegen/supabase_codegen.dart';
import 'package:test/test.dart';

void main() {
  group('generateEnumsFile', () {
    late Directory testEnumsDir;
    const enumRpc = 'get_enum_types';
    const testEnumName = 'enum_test';
    const testOutputFolder = 'test/test_output_enums';
    final fileMatchRegExp = RegExp("export '(?<file>.+)';");

    logger = testLogger;

    setUp(() {
      client = mockSupabase;
      mockSupabaseHttpClient.reset();
      final dirPath =
          path.join(Directory.current.path, '$testOutputFolder/enums');
      testEnumsDir = Directory(dirPath);

      // Ensure test output directory exists
      if (!testEnumsDir.existsSync()) {
        testEnumsDir.createSync(recursive: true);
      }
    });

    tearDown(() {
      // Clean up test output
      if (testEnumsDir.parent.existsSync()) {
        testEnumsDir.parent.deleteSync(recursive: true);
      }
    });

    /// Generate the enums for the provided [enumData]
    Future<String> generateEnumWithData(dynamic enumData) async {
      mockSupabaseHttpClient.registerRpcFunction(
        enumRpc,
        (params, tables) => enumData,
      );
      await generateEnums(testEnumsDir);

      final enumFile = File('${testEnumsDir.path}/$enumsFileName.dart');
      expect(enumFile.existsSync(), isTrue);
      return enumFile.readAsStringSync();
    }

    /// Get the enum file contents for the given [enumData].
    ///
    /// Should be used only for
    Future<String> enumFileContentFor(dynamic enumData) async {
      final enumContent = await generateEnumWithData(enumData);

      final files = fileMatchRegExp.allMatches(enumContent);
      expect(files.length, equals(1));
      final fileName = files.first.namedGroup('file');
      final file = File('${testEnumsDir.path}/$fileName');
      expect(file.existsSync(), isTrue);
      return file.readAsStringSync();
    }

    test('generates enum files successfully with proper content', () async {
      final fileContent = await enumFileContentFor([
        {'enum_name': testEnumName, 'enum_value': 'value1'},
        {'enum_name': testEnumName, 'enum_value': 'value2'},
      ]);

      expect(fileContent, contains('enum ${testEnumName.toPascalCase()}'));
      expect(fileContent, contains('value1'));
      expect(fileContent, contains('value2'));
      expect(fileContent, contains('/// ${testEnumName.toCapitalCase()} enum'));
      // expect(fileContent, contains('Generated by supabase_codegen'));
    });

    test('generates multiple enums in separate files', () async {
      final enumContent = await generateEnumWithData([
        {'enum_name': 'enum_one', 'enum_value': 'value1'},
        {'enum_name': 'enum_one', 'enum_value': 'value2'},
        {'enum_name': 'enum_two', 'enum_value': 'valueA'},
        {'enum_name': 'enum_two', 'enum_value': 'valueB'},
      ]);

      final files = fileMatchRegExp.allMatches(enumContent);
      expect(files.length, equals(2));

      final fileOne = files.elementAt(0).namedGroup('file');
      final fileOneContent =
          File('${testEnumsDir.path}/$fileOne').readAsStringSync();
      expect(fileOneContent, contains('enum EnumOne'));
      expect(fileOneContent, contains('value1'));
      expect(fileOneContent, contains('value2'));
      expect(fileOneContent, contains('/// Enum One enum'));
      expect(fileOneContent, contains('Generated by supabase_codegen'));

      final fileTwo = files.elementAt(1).namedGroup('file');
      final fileTwoContent =
          File('${testEnumsDir.path}/$fileTwo').readAsStringSync();
      expect(fileTwoContent, contains('enum EnumTwo'));
      expect(fileTwoContent, contains('valueA'));
      expect(fileTwoContent, contains('valueB'));
      expect(fileTwoContent, contains('/// Enum Two enum'));
      expect(fileTwoContent, contains('Generated by supabase_codegen'));
    });

    test('handles enum names with underscores and "Enum" suffix', () async {
      final enumContent = await generateEnumWithData([
        {'enum_name': 'my_test_enum_enum', 'enum_value': 'value1'},
        {'enum_name': 'my_test_enum_enum', 'enum_value': 'value2'},
        {'enum_name': 'another_enum', 'enum_value': 'valueA'},
      ]);

      final files = fileMatchRegExp.allMatches(enumContent);
      expect(files.length, equals(2));

      final fileOne = files.elementAt(0).namedGroup('file');
      final fileOneContent =
          File('${testEnumsDir.path}/$fileOne').readAsStringSync();
      expect(fileOneContent, contains('enum MyTestEnum'));

      final fileTwo = files.elementAt(1).namedGroup('file');
      final fileTwoContent =
          File('${testEnumsDir.path}/$fileTwo').readAsStringSync();
      expect(fileTwoContent, contains('enum Another'));
    });

    test('handles enum values with slashes', () async {
      final enumContent = await enumFileContentFor([
        {'enum_name': 'slash_enum', 'enum_value': 'value/1'},
        {'enum_name': 'slash_enum', 'enum_value': 'value/2'},
      ]);

      expect(enumContent, contains('value_1'));
      expect(enumContent, contains('value_2'));
    });

    test('handles empty enum response', () async {
      final enumContent = await generateEnumWithData(<dynamic>[]);

      expect(enumContent, contains('//'));
      expect(enumContent, contains('Generated file. Do not edit.'));
      expect(enumContent, contains('Generated by supabase_codegen'));
    });

    test('throws exception when fetching enums fails', () async {
      mockSupabaseHttpClient.registerRpcFunction(
        enumRpc,
        (params, tables) => throw Exception('Failed to fetch'),
      );

      expect(
        () => generateEnums(testEnumsDir),
        throwsException,
      );
    });

    test('handles a different response format', () async {
      final enumData = {
        'data': [
          {'enum_name': 'diff_types', 'enum_value': 'value1'},
          {'enum_name': 'diff_types', 'enum_value': 'value2'},
        ],
      };
      final enumContent = await enumFileContentFor(enumData);

      expect(enumContent, contains('enum DiffTypes'));
      expect(enumContent, contains('value1'));
      expect(enumContent, contains('value2'));
    });
  });
}
