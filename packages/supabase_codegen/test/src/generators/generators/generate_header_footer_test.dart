import 'dart:io';

import 'package:mocktail/mocktail.dart';
import 'package:supabase_codegen/src/generator/generator.dart';
import 'package:test/test.dart';

class MockFile extends Mock implements File {}

void main() {
  setUp(() {
    skipFooterWrite = false;
  });

  group('writeHeader and writeFooter', () {
    test('writeHeader writes correct header', () {
      final buffer = StringBuffer();
      writeHeader(buffer);
      expect(buffer.toString(), contains('//'));
      expect(buffer.toString(), contains('Generated file. Do not edit.'));
      expect(buffer.toString(), contains('Generated by supabase_codegen'));
      expect(buffer.toString(), contains(version));
      expect(
        buffer.toString(),
        contains('// ignore_for_file: require_trailing_commas, '
            'constant_identifier_names'),
      );
    });

    group('writeFooter writes', () {
      test('correct footer with tag', () {
        final buffer = StringBuffer();
        tag = 'test_tag';
        writeFooter(buffer);
        expect(buffer.toString(), contains('Tag: test_tag'));
      });

      test('correct footer without tag', () {
        final buffer = StringBuffer();
        tag = '';
        writeFooter(buffer);
        expect(buffer.toString(), isNot(contains('Tag:')));
      });

      group('when skipFooter is true', () {
        setUp(() {
          skipFooterWrite = true;
        });
        test('no date', () {
          final buffer = StringBuffer();
          tag = '';
          writeFooter(buffer);
          expect(buffer.toString(), isEmpty);
        });
        test('tag if provided', () {
          final buffer = StringBuffer();
          tag = 'test_tag';
          writeFooter(buffer);
          expect(buffer.toString(), contains('Tag: test_tag'));
        });
      });

      test('date when skipFooter is false', () {
        final buffer = StringBuffer();
        writeFooter(buffer);
        expect(buffer.toString(), isNotEmpty);
        expect(buffer.toString(), contains('Date:'));
      });
    });

    group('removeFileFormatting', () {
      const line = 'Hello';
      test('removes all spaces', () {
        const withSpaces = '  $line';
        expect(removeFileFormatting(withSpaces), equals(line));
      });

      test('removes all tabs', () {
        const withTabs = '\t$line';
        expect(removeFileFormatting(withTabs), equals(line));
      });

      test('removes all newlines', () {
        const withNewlines = '''
$line
''';
        expect(removeFileFormatting(withNewlines), equals(line));
      });

      test('removes all commas', () {
        const withComma = '$line,';
        expect(removeFileFormatting(withComma), equals(line));
      });
    });

    group('writeFileIfChangedIgnoringDate', () {
      /// Load the buffer
      void loadBuffer(StringBuffer buffer) {
        writeHeader(buffer);
        writeFooter(buffer);
      }

      var mockFile = MockFile();
      var buffer = StringBuffer();
      var content = '';

      setUp(() {
        mockFile = MockFile();
        buffer = StringBuffer();
        loadBuffer(buffer);

        when(() => mockFile.existsSync()).thenAnswer((_) => content.isNotEmpty);
        when(() => mockFile.writeAsStringSync(any())).thenAnswer(
          (invocation) {
            expect(invocation.positionalArguments, isNotEmpty);
            content = invocation.positionalArguments[0] as String;
          },
        );
        when(() => mockFile.readAsStringSync()).thenAnswer((_) => content);
      });

      tearDown(() {
        buffer.clear();
        mockFile.deleteSync();
        content = '';
      });

      void verifyFileExistenceChecked({required int times}) =>
          verify(() => mockFile.existsSync()).called(times);

      void verifyFileContentsRead({required int times}) =>
          verify(() => mockFile.readAsStringSync()).called(times);

      void verifyFileContentsNotRead() =>
          verifyNever(() => mockFile.readAsStringSync());

      void verifyFileWritten({required int times}) =>
          verify(() => mockFile.writeAsStringSync(any())).called(times);

      test('writes new file if it does not exist', () {
        writeFileIfChangedIgnoringDate(mockFile, buffer);
        // Existence checked but contents never read
        verifyFileExistenceChecked(times: 1);
        verifyFileContentsNotRead();
        // File written
        verifyFileWritten(times: 1);
      });

      group(
          'when the content is the same ignoring date, '
          'then the file is not updated', () {
        // Rewrite the buffer and verify no updates
        void rewriteBufferAndVerifyNoUpdates() {
          // Create a new buffer and attempt write
          final buffer2 = StringBuffer();
          loadBuffer(buffer2);
          writeFileIfChangedIgnoringDate(mockFile, buffer2);

          // Existence checked, file read but not written
          verifyFileExistenceChecked(times: 2);
          verifyFileContentsRead(times: 1);
          verifyFileWritten(times: 1);
        }

        test('with original formatting', () {
          // Write the file initially
          writeFileIfChangedIgnoringDate(mockFile, buffer);

          rewriteBufferAndVerifyNoUpdates();
        });

        test('with updated formatting between files', () {
          writeFileIfChangedIgnoringDate(mockFile, buffer);

          // Update the formatting of the current content
          content = content.replaceAll('///', '  ///');

          rewriteBufferAndVerifyNoUpdates();
        });
      });

      test('rewrites file if content differs ignoring date', () {
        writeFileIfChangedIgnoringDate(mockFile, buffer);

        // Create new content
        final buffer2 = StringBuffer();
        writeHeader(buffer2);
        buffer2.writeln('// Additional line to change content');
        writeFooter(buffer2);

        // Write the new content
        writeFileIfChangedIgnoringDate(mockFile, buffer2);

        verifyFileExistenceChecked(times: 2);
        verifyFileContentsRead(times: 1);
        verifyFileWritten(times: 2);
      });
    });
  });
}
